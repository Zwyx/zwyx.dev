"use strict";(self.webpackChunkzwyx_dev=self.webpackChunkzwyx_dev||[]).push([[2673],{8658:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var i=n(5258),s=n(4848),r=n(8453);const a={slug:"base-conversions-with-big-numbers-in-javascript",title:"Base conversions with BIG numbers in JavaScript",description:"How to rapidly convert very big numbers from one base to another in JavaScript.",authors:["alex"],tags:["base conversion","v8","integer","bigint","string","algorithm","javascript"]},o=void 0,l={authorsImageUrls:[void 0]},d=[{value:"From string",id:"from-string",level:2},{value:"To string",id:"to-string",level:2},{value:"Unexpected turn of events!",id:"unexpected-turn-of-events",level:2},{value:"Future",id:"future",level:2}];function c(t){const e={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...t.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.p,{children:["For the ",(0,s.jsx)(e.a,{href:"https://babel.zwyx.dev",children:"Library of Babel"}),", I needed to convert very big numbers \u2014 hundreds of thousands of digits \u2014 from a base to another."]}),"\n","\n",(0,s.jsxs)(e.p,{children:["However, ",(0,s.jsx)(e.code,{children:"BigInt"})," is limited:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["from string \u2192 the constructor ",(0,s.jsx)(e.code,{children:"BigInt()"})," accepts strings in bases 2, 8, 10, and 16, only;"]}),"\n",(0,s.jsxs)(e.li,{children:["to string \u2192 ",(0,s.jsx)(e.code,{children:"toString()"})," accepts a base of between 2 and 36."]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["I needed to work with bases 29 and 94, ",(0,s.jsx)(e.code,{children:"BigInt"})," wasn't able to handle this. So I tried to implement the necessary algorithms in JavaScript."]}),"\n",(0,s.jsx)(e.h2,{id:"from-string",children:"From string"}),"\n",(0,s.jsxs)(e.p,{children:["To convert a ",(0,s.jsx)(e.strong,{children:"string to an integer"}),", the classic algorithm is:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'const fromBase = (text: string, alphabet: string = "0123456789"): bigint => {\n\tconst base = BigInt(alphabet.length);\n\n\tlet result = 0n;\n\n\t// Start from the left of the string\n\tfor (let i = 0; i < text.length; i++) {\n\t\t// for each digit, take the previous result,\n\t\t// multiply it by the base, and add the new digit\n\t\tresult = result * base + BigInt(alphabet.indexOf(text.charAt(i)));\n\t}\n\n\t/* or we could do that, but it\'s slower:\n\t// starting from the right of the string\n\tfor (let i = text.length - 1; i >= 0; i--) {\n\t\t// multiply each digit by the base to the power of\n\t\t// the digit position, and add it to the result\n\t\tresult +=\n\t\t\tBigInt(alphabet.indexOf(text.charAt(i))) *\n\t\t\tbase ** BigInt(text.length - 1 - i);\n\t}\n\t*/\n\n\treturn result;\n};\n'})}),"\n",(0,s.jsxs)(e.p,{children:["However, this is quite slow: it takes ",(0,s.jsx)(e.strong,{children:"30s"})," on my machine to convert a string containing ",(0,s.jsx)(e.strong,{children:"500,000 random digits in base 10"}),". (I tried to compile it to WebAssembly with AssemblyScript, but it made it even slower.)"]}),"\n",(0,s.jsxs)(e.p,{children:["Whereas it takes V8's ",(0,s.jsx)(e.code,{children:"BigInt"})," only ",(0,s.jsx)(e.strong,{children:"100ms"}),"!"]}),"\n",(0,s.jsxs)(e.p,{children:["Turns out, ",(0,s.jsx)(e.code,{children:"BigInt"})," uses a different algorithm, which can be found in V8's ",(0,s.jsx)(e.a,{href:"https://github.com/v8/v8/blob/19853e10095df4aa640d6d3377c532c8a22ae1c5/src/bigint/fromstring.cc#L50",children:(0,s.jsx)(e.code,{children:"FromStringLarge"})})," function."]}),"\n",(0,s.jsx)(e.p,{children:"I'll leave it to you to read the description in V8's source code to understand how it works, and here is my JavaScript version:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'const fromBase = (text: string, alphabet: string = "0123456789"): bigint => {\n\tconst base = BigInt(alphabet.length);\n\n\tlet parts = text\n\t\t.split("")\n\t\t.map((part) => [BigInt(alphabet.indexOf(part)), base]);\n\n\tif (parts.length === 1) {\n\t\treturn parts[0][0];\n\t}\n\n\tlet pairFull: boolean;\n\twhile (parts.length > 2) {\n\t\tpairFull = false;\n\t\tparts = parts.reduce<bigint[][]>((acc, cur, i) => {\n\t\t\tif (!pairFull) {\n\t\t\t\tif (i === parts.length - 1) {\n\t\t\t\t\tacc.push(cur);\n\t\t\t\t} else {\n\t\t\t\t\tacc.push([\n\t\t\t\t\t\tcur[0] * parts[i + 1][1] + parts[i + 1][0],\n\t\t\t\t\t\tcur[1] * parts[i + 1][1],\n\t\t\t\t\t]);\n\t\t\t\t\tpairFull = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpairFull = false;\n\t\t\t}\n\t\t\treturn acc;\n\t\t}, []);\n\t}\n\n\treturn parts[0][0] * parts[1][1] + parts[1][0];\n};\n'})}),"\n",(0,s.jsxs)(e.p,{children:["It now takes ",(0,s.jsx)(e.strong,{children:"120ms"})," to do the conversion! Just slightly slower than native ",(0,s.jsx)(e.code,{children:"BigInt"}),". (And without any optimisations that are mentioned in V8's code.)"]}),"\n",(0,s.jsx)(e.p,{children:"It's a bit counter intuitive, because this algorithm does about 1,000,000 iterations, instead of 500,000 for the classic algorithm (which does one for each digit). The reason is apparently that the multiplications are smaller, and possibly more optimisable because involving parts of the same size."}),"\n",(0,s.jsx)(e.h2,{id:"to-string",children:"To string"}),"\n",(0,s.jsxs)(e.p,{children:["To convert an ",(0,s.jsx)(e.strong,{children:"integer to a string"}),", the classic algorithm is the successive division method:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'const toBase = (value: bigint, alphabet: string = "0123456789"): string => {\n\tconst base = BigInt(alphabet.length);\n\n\tlet result = "";\n\n\t// At start, the dividend is equal to the value\n\tlet dividend = value;\n\tlet remainder;\n\n\twhile (dividend >= base) {\n\t\t// We get the remainder of the dividend modulo the base\n\t\tremainder = dividend % base;\n\t\t// and we append it to the result, from right to left\n\t\tresult = alphabet[Number(remainder)] + result;\n\t\t// then we divide the dividend by the base\n\t\t// and that gives us the dividend for the next iteration\n\t\tdividend = dividend / base;\n\t}\n\tresult = alphabet[Number(dividend)] + result;\n\n\treturn result;\n};\n'})}),"\n",(0,s.jsx)(e.p,{children:"However, this is again quite slow: 30s to convert a bigint of 500,000 random digits in base 10."}),"\n",(0,s.jsxs)(e.p,{children:["For this too, V8's ",(0,s.jsx)(e.code,{children:"BigInt"})," is much faster, and uses a different algorithm, ",(0,s.jsx)(e.a,{href:"https://github.com/v8/v8/blob/19853e10095df4aa640d6d3377c532c8a22ae1c5/src/bigint/tostring.cc#L275",children:(0,s.jsx)(e.em,{children:"divide-and-conquer conversion"})}),"."]}),"\n",(0,s.jsx)(e.p,{children:"I recommend again to read the description in V8's code, as I couldn't explain it better, and here is my JavaScript version:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:'const toBase = (value: bigint, alphabet: string = "0123456789"): string => {\n\tconst base = BigInt(alphabet.length);\n\n\tlet result = "";\n\n\tconst divisors = [base];\n\n\tconst numberOfBitsInValue = value.toString(2).length;\n\n\twhile (divisors.at(-1).toString(2).length * 2 - 1 <= numberOfBitsInValue) {\n\t\tdivisors.push(divisors.at(-1) ** 2n);\n\t}\n\n\tconst divide = (dividend: bigint, divisorIndex: number) => {\n\t\tconst divisor = divisors[divisorIndex];\n\n\t\tconst remainder = dividend % divisor;\n\t\tconst newDividend = dividend / divisor;\n\n\t\tif (divisorIndex > 0) {\n\t\t\tdivide(remainder, divisorIndex - 1);\n\t\t\tdivide(newDividend, divisorIndex - 1);\n\t\t} else {\n\t\t\tresult = `${alphabet[Number(newDividend)]}${\n\t\t\t\talphabet[Number(remainder)]\n\t\t\t}${result}`;\n\t\t}\n\t};\n\n\tdivide(value, divisors.length - 1, true);\n\n\tresult = result.replace(new RegExp(`^${alphabet[0]}*`), "");\n\n\treturn result;\n};\n'})}),"\n",(0,s.jsxs)(e.p,{children:["It now takes ",(0,s.jsx)(e.strong,{children:"150ms"})," to do the conversion! (Also without any optimisations.)"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsxs)(e.p,{children:["And that's it. These two fast algorithms made possible my version of the ",(0,s.jsx)(e.a,{href:"https://babel.zwyx.dev",children:"the Library of Babel"}),", which works entirely client-side."]}),"\n",(0,s.jsx)(e.h2,{id:"unexpected-turn-of-events",children:"Unexpected turn of events!"}),"\n",(0,s.jsxs)(e.p,{children:["Thanks to these algorithms, I was able to finish the ",(0,s.jsx)(e.a,{href:"https://babel.zwyx.dev",children:"the Library of Babel"}),". Every operation was taking a couple of seconds, at most, on my computer."]}),"\n",(0,s.jsx)(e.p,{children:"However, when testing the app on my phone, I realised that one operation was very slow: it took more than 3 minutes!"}),"\n",(0,s.jsxs)(e.p,{children:["It turned out that it was a ",(0,s.jsx)(e.code,{children:".toString()"})," call on a very large bigint. The need was to convert this bigint to a string in base 10, so I didn't bother changing this ",(0,s.jsx)(e.code,{children:".toString()"})," to use the new algorithm ",(0,s.jsx)(e.code,{children:"toBase"}),", because ",(0,s.jsx)(e.code,{children:".toString()"})," is able to handle base 10."]}),"\n",(0,s.jsxs)(e.p,{children:["However, V8's ",(0,s.jsx)(e.a,{href:"https://github.com/v8/v8/blob/main/src/bigint/tostring.cc",children:"source code"})," shows that the fast ",(0,s.jsx)(e.code,{children:".toString"})," algorithm is behind the flag ",(0,s.jsx)(e.code,{children:"V8_ADVANCED_BIGINT_ALGORITHMS"}),"."]}),"\n",(0,s.jsx)(e.p,{children:"I guess this flag is ON when Chrome is built for Linux desktop, but OFF when it's built for Android."}),"\n",(0,s.jsxs)(e.p,{children:["I simply replaced ",(0,s.jsx)(e.code,{children:".toString()"})," by a call to ",(0,s.jsx)(e.code,{children:"toBase(...)"})," and the app became fast on my phone too!"]}),"\n",(0,s.jsx)(e.admonition,{type:"note",children:(0,s.jsxs)(e.p,{children:["There is also a call to ",(0,s.jsx)(e.code,{children:".toString(16)"})," on the same number, but this one is very quick. The algorithm for base 16 must be much faster because it just has to split every byte into two hexadecimal values. So I didn't have to change this one."]})}),"\n",(0,s.jsx)(e.h2,{id:"future",children:"Future"}),"\n",(0,s.jsxs)(e.p,{children:["There is ",(0,s.jsx)(e.a,{href:"https://github.com/tc39/proposal-number-fromstring",children:"a TC39 proposal"})," to give ",(0,s.jsx)(e.code,{children:"BigInt"})," more capabilities, but as of 2023, it doesn't look like it's getting much traction."]})]})}function h(t={}){const{wrapper:e}={...(0,r.R)(),...t.components};return e?(0,s.jsx)(e,{...t,children:(0,s.jsx)(c,{...t})}):c(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>a,x:()=>o});var i=n(6540);const s={},r=i.createContext(s);function a(t){const e=i.useContext(r);return i.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function o(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(s):t.components||s:a(t.components),i.createElement(r.Provider,{value:e},t.children)}},5258:t=>{t.exports=JSON.parse('{"permalink":"/blog/base-conversions-with-big-numbers-in-javascript","editUrl":"https://github.com/zwyx/zwyx.dev/tree/master/blog/2024-02-06-base-conversions-with-big-numbers-in-javascript/index.mdx","source":"@site/blog/2024-02-06-base-conversions-with-big-numbers-in-javascript/index.mdx","title":"Base conversions with BIG numbers in JavaScript","description":"How to rapidly convert very big numbers from one base to another in JavaScript.","date":"2024-02-06T00:00:00.000Z","tags":[{"inline":true,"label":"base conversion","permalink":"/blog/tags/base-conversion"},{"inline":true,"label":"v8","permalink":"/blog/tags/v-8"},{"inline":true,"label":"integer","permalink":"/blog/tags/integer"},{"inline":true,"label":"bigint","permalink":"/blog/tags/bigint"},{"inline":true,"label":"string","permalink":"/blog/tags/string"},{"inline":true,"label":"algorithm","permalink":"/blog/tags/algorithm"},{"inline":true,"label":"javascript","permalink":"/blog/tags/javascript"}],"readingTime":4.97,"hasTruncateMarker":true,"authors":[{"name":"Alex","title":"Web developer","email":"alex@zwyx.dev","url":"https://github.com/Zwyx","imageURL":"https://github.com/zwyx.png","key":"alex","page":null}],"frontMatter":{"slug":"base-conversions-with-big-numbers-in-javascript","title":"Base conversions with BIG numbers in JavaScript","description":"How to rapidly convert very big numbers from one base to another in JavaScript.","authors":["alex"],"tags":["base conversion","v8","integer","bigint","string","algorithm","javascript"]},"unlisted":false,"prevItem":{"title":"Protect yourself from malicious NPM packages with a system-wide dev container","permalink":"/blog/docker-dev"},"nextItem":{"title":"Type-safe translations with TypeScript and i18next","permalink":"/blog/typesafe-translations"}}')}}]);